abline(a = 1, b = 5.016516e-06)
abline(a = 1, b = 10.016516e-06)
abline(a = 4, b = 10.016516e-06)
abline(a = 2, b = 10.016516e-06)
plot(x,y,col=rgb(0.4,0.4,0.8,0.6),pch=16 , cex=1.3)
abline(a = 2, b = 10.016516e-06)
abline(a = 0, b = 10.016516e-06)
abline(a = 0, b = 8.016516e-06)
abline(a = 0, b = 7.016516e-06)
abline(a = 0, b = 5.016516e-06)
plot(dexp)
plot(dexp(1))
?dexp
dexp(seq(1, 10, .001))
plot(dexp(seq(1, 10, .001)))
?dexp
x <- runs$size
y <- sapply(runs$MaxRSS, function(x) as.numeric(substr(x, 1, nchar(x)-1)))
y <- runs$Elapsed
plot(x,y,col=rgb(0.4,0.4,0.8,0.6),pch=16 , cex=1.3)
abline(a = 0, b = 5.016516e-06)
model$coefficients
# Can we find a polynome that fit this function ?
model <- lm(y ~ x)
model$coefficients
abline(a = -1.994421e+00, b = 6.908190e-06)
abline(a = 0, b = 6.908190e-06)
abline(a = 1, b = 6.908190e-06)
plot(x,y,col=rgb(0.4,0.4,0.8,0.6),pch=16 , cex=1.3)
abline(a = 1, b = 6.908190e-06)
abline(a = 0, b = 6.908190e-06)
abline(a = -1, b = 6.908190e-06)
abline(a = -.5, b = 6.908190e-06)
x <- log(runs$size)
plot(x,y,col=rgb(0.4,0.4,0.8,0.6),pch=16 , cex=1.3)
x <- (runs$size)^2
y <- runs$Elapsed
plot(x,y,col=rgb(0.4,0.4,0.8,0.6),pch=16 , cex=1.3)
x <- log(runs$size)
x <- log(runs$size)
y <- runs$Elapsed
plot(x,y,col=rgb(0.4,0.4,0.8,0.6),pch=16 , cex=1.3)
abline(a = -.5, b = 6.908190e-06)
# Can we find a polynome that fit this function ?
model <- lm(y ~ x + I(x^2))
# I can get the features of this model :
summary(model)
model$coefficients
summary(model)$adj.r.squared
# For each value of x, I can get the value of y estimated by the model, and add it to the current plot !
myPredict <- predict( model )
myPredict <- myPredict + 10
ix <- sort(x,index.return=T)$ix
lines(x[ix], myPredict[ix], col=2, lwd=2 )
# Can we find a polynome that fit this function ?
model <- lm(y ~ I(x^2))
# I can get the features of this model :
summary(model)
model$coefficients
summary(model)$adj.r.squared
# For each value of x, I can get the value of y estimated by the model, and add it to the current plot !
myPredict <- predict( model )
myPredict <- myPredict + 10
ix <- sort(x,index.return=T)$ix
lines(x[ix], myPredict[ix], col=2, lwd=2 )
# Can we find a polynome that fit this function ?
model <- lm(y ~ exp(x))
# I can get the features of this model :
summary(model)
model$coefficients
summary(model)$adj.r.squared
# For each value of x, I can get the value of y estimated by the model, and add it to the current plot !
myPredict <- predict( model )
myPredict <- myPredict + 10
ix <- sort(x,index.return=T)$ix
lines(x[ix], myPredict[ix], col=2, lwd=2 )
plot(x,y,col=rgb(0.4,0.4,0.8,0.6),pch=16 , cex=1.3)
lines(x[ix], myPredict[ix], col=2, lwd=2 )
# Can we find a polynome that fit this function ?
model <- lm(y ~ x + exp(x))
# I can get the features of this model :
summary(model)
model$coefficients
summary(model)$adj.r.squared
# For each value of x, I can get the value of y estimated by the model, and add it to the current plot !
myPredict <- predict( model )
myPredict <- myPredict + 10
ix <- sort(x,index.return=T)$ix
lines(x[ix], myPredict[ix], col=2, lwd=2 )
x <- runs$size
y <- runs$Elapsed
plot(x,y,col=rgb(0.4,0.4,0.8,0.6),pch=16 , cex=1.3)
# Can we find a polynome that fit this function ?
model <- lm(y ~ x + exp(x))
# I can get the features of this model :
summary(model)
model$coefficients
summary(model)$adj.r.squared
# For each value of x, I can get the value of y estimated by the model, and add it to the current plot !
myPredict <- predict( model )
myPredict <- myPredict + 10
ix <- sort(x,index.return=T)$ix
lines(x[ix], myPredict[ix], col=2, lwd=2 )
x <- log(runs$size)
y <- runs$Elapsed
# Can we find a polynome that fit this function ?
model <- lm(y ~ x + exp(x))
# I can get the features of this model :
summary(model)
model$coefficients
summary(model)$adj.r.squared
# For each value of x, I can get the value of y estimated by the model, and add it to the current plot !
myPredict <- predict( model )
myPredict <- myPredict + 10
ix <- sort(x,index.return=T)$ix
lines(x[ix], myPredict[ix], col=2, lwd=2 )
library(chron)
head(runs)
runs$Elapsed <- 60 * 24 * as.numeric(times(runs$Elapsed))
x <- log(runs$size)
# y <- sapply(runs$MaxRSS, function(x) as.numeric(substr(x, 1, nchar(x)-1)))
y <- runs$Elapsed
plot(x,y,col=rgb(0.4,0.4,0.8,0.6),pch=16 , cex=1.3)
abline(a = -.5, b = 6.908190e-06)
# Can we find a polynome that fit this function ?
model <- lm(y ~ x + exp(x))
# I can get the features of this model :
summary(model)
model$coefficients
summary(model)$adj.r.squared
# For each value of x, I can get the value of y estimated by the model, and add it to the current plot !
myPredict <- predict( model )
myPredict <- myPredict + 10
ix <- sort(x,index.return=T)$ix
lines(x[ix], myPredict[ix], col=2, lwd=2 )
library(chron)
head(runs)
runs$Elapsed <- 60 * 24 * as.numeric(times(runs$Elapsed))
x <- log(runs$size)
# y <- sapply(runs$MaxRSS, function(x) as.numeric(substr(x, 1, nchar(x)-1)))
y <- runs$Elapsed
plot(x,y,col=rgb(0.4,0.4,0.8,0.6),pch=16 , cex=1.3)
abline(a = -.5, b = 6.908190e-06)
# Can we find a polynome that fit this function ?
model <- lm(y ~ x + exp(x))
# I can get the features of this model :
summary(model)
model$coefficients
summary(model)$adj.r.squared
# For each value of x, I can get the value of y estimated by the model, and add it to the current plot !
myPredict <- predict( model )
ix <- sort(x,index.return=T)$ix
lines(x[ix], myPredict[ix], col=2, lwd=2 )
lines(x[ix], myPredict[ix] + 2, col=2, lwd=2 )
library(chron)
head(runs)
runs$Elapsed <- 60 * 24 * as.numeric(times(runs$Elapsed))
x <- log(runs$size)
# y <- sapply(runs$MaxRSS, function(x) as.numeric(substr(x, 1, nchar(x)-1)))
y <- runs$Elapsed
plot(x,y,col=rgb(0.4,0.4,0.8,0.6),pch=16 , cex=1.3)
abline(a = -.5, b = 6.908190e-06)
# Can we find a polynome that fit this function ?
model <- lm(y ~ x + exp(x))
# I can get the features of this model :
summary(model)
model$coefficients
summary(model)$adj.r.squared
# For each value of x, I can get the value of y estimated by the model, and add it to the current plot !
myPredict <- predict( model ) +2
ix <- sort(x,index.return=T)$ix
lines(x[ix], myPredict[ix], col=2, lwd=2 )
library(chron)
head(runs)
runs$Elapsed <- 60 * 24 * as.numeric(times(runs$Elapsed))
x <- log(runs$size)
# y <- sapply(runs$MaxRSS, function(x) as.numeric(substr(x, 1, nchar(x)-1)))
y <- runs$Elapsed
plot(x,y,col=rgb(0.4,0.4,0.8,0.6),pch=16 , cex=1.3)
abline(a = -.5, b = 6.908190e-06)
# Can we find a polynome that fit this function ?
model <- lm(y ~ x + exp(x))
# I can get the features of this model :
summary(model)
model$coefficients
summary(model)$adj.r.squared
# For each value of x, I can get the value of y estimated by the model, and add it to the current plot !
myPredict <- predict( model ) + 1-
ix <- sort(x,index.return=T)$ix
lines(x[ix], myPredict[ix], col=2, lwd=2 )
library(chron)
head(runs)
runs$Elapsed <- 60 * 24 * as.numeric(times(runs$Elapsed))
x <- log(runs$size)
# y <- sapply(runs$MaxRSS, function(x) as.numeric(substr(x, 1, nchar(x)-1)))
y <- runs$Elapsed
plot(x,y,col=rgb(0.4,0.4,0.8,0.6),pch=16 , cex=1.3)
abline(a = -.5, b = 6.908190e-06)
# Can we find a polynome that fit this function ?
model <- lm(y ~ x + exp(x))
# I can get the features of this model :
summary(model)
model$coefficients
summary(model)$adj.r.squared
# For each value of x, I can get the value of y estimated by the model, and add it to the current plot !
myPredict <- predict( model ) + 10
ix <- sort(x,index.return=T)$ix
lines(x[ix], myPredict[ix], col=2, lwd=2 )
library(chron)
head(runs)
runs$Elapsed <- 60 * 24 * as.numeric(times(runs$Elapsed))
x <- log(runs$size)
# y <- sapply(runs$MaxRSS, function(x) as.numeric(substr(x, 1, nchar(x)-1)))
y <- runs$Elapsed
plot(x,y,col=rgb(0.4,0.4,0.8,0.6),pch=16 , cex=1.3)
abline(a = -.5, b = 6.908190e-06)
# Can we find a polynome that fit this function ?
model <- lm(y ~ x + exp(x))
# I can get the features of this model :
summary(model)
model$coefficients
summary(model)$adj.r.squared
# For each value of x, I can get the value of y estimated by the model, and add it to the current plot !
myPredict <- predict( model ) + 500
ix <- sort(x,index.return=T)$ix
lines(x[ix], myPredict[ix], col=2, lwd=2 )
library(chron)
head(runs)
runs$Elapsed <- 60 * 24 * as.numeric(times(runs$Elapsed))
x <- log(runs$size)
# y <- sapply(runs$MaxRSS, function(x) as.numeric(substr(x, 1, nchar(x)-1)))
y <- runs$Elapsed
plot(x,y,col=rgb(0.4,0.4,0.8,0.6),pch=16 , cex=1.3)
abline(a = -.5, b = 6.908190e-06)
# Can we find a polynome that fit this function ?
model <- lm(y ~ x + exp(x))
# I can get the features of this model :
summary(model)
model$coefficients
summary(model)$adj.r.squared
# For each value of x, I can get the value of y estimated by the model, and add it to the current plot !
myPredict <- predict( model )
ix <- sort(x,index.return=T)$ix
lines(x[ix], myPredict[ix], col=2, lwd=2 )
myPredict[ix]
model$coefficients
runs$size
log(runs$size)
model$coefficients
myPredict
x <- log(runs$size)
# y <- sapply(runs$MaxRSS, function(x) as.numeric(substr(x, 1, nchar(x)-1)))
y <- runs$Elapsed
plot(x,y,col=rgb(0.4,0.4,0.8,0.6),pch=16 , cex=1.3)
y
runs$Elapsed
runs <- read.delim("~/Desktop/runs.csv")
View(runs)
x <- log(runs$size)
y <- 60 * 24 * as.numeric(times(runs$Elapsed))
plot(x,y,col=rgb(0.4,0.4,0.8,0.6),pch=16 , cex=1.3)
# Can we find a polynome that fit this function ?
model <- lm(y ~ x + exp(x))
# I can get the features of this model :
summary(model)
model$coefficients
summary(model)
model$coefficients
summary(model)$adj.r.squared
# For each value of x, I can get the value of y estimated by the model, and add it to the current plot !
myPredict <- predict( model )
ix <- sort(x,index.return=T)$ix
lines(x[ix], myPredict[ix], col=2, lwd=2 )
# For each value of x, I can get the value of y estimated by the model, and add it to the current plot !
myPredict <- predict( model ) -2
ix <- sort(x,index.return=T)$ix
lines(x[ix], myPredict[ix], col=2, lwd=2 )
library(chron)
head(runs)
x <- log(runs$size)
y <- 60 * 24 * as.numeric(times(runs$Elapsed))
plot(x,y,col=rgb(0.4,0.4,0.8,0.6),pch=16 , cex=1.3)
# Can we find a polynome that fit this function ?
model <- lm(y ~ x + exp(x))
# I can get the features of this model :
summary(model)
model$coefficients
summary(model)$adj.r.squared
# For each value of x, I can get the value of y estimated by the model, and add it to the current plot !
myPredict <- predict( model ) -1
ix <- sort(x,index.return=T)$ix
lines(x[ix], myPredict[ix], col=2, lwd=2 )
library(chron)
head(runs)
x <- log(runs$size)
y <- 60 * 24 * as.numeric(times(runs$Elapsed))
plot(x,y,col=rgb(0.4,0.4,0.8,0.6),pch=16 , cex=1.3)
# Can we find a polynome that fit this function ?
model <- lm(y ~ x + exp(x))
# I can get the features of this model :
summary(model)
model$coefficients
summary(model)$adj.r.squared
# For each value of x, I can get the value of y estimated by the model, and add it to the current plot !
myPredict <- predict( model ) * .75
ix <- sort(x,index.return=T)$ix
lines(x[ix], myPredict[ix], col=2, lwd=2 )
?quap
library(rethinking)
?quap
exp(100000000)
exp(10000)
exp(-10000)
library(rethinking)
data(rugged)
d <-rugged
# makelogversionofoutcome
d$log_gdp <-log(d$rgdppc_2000)
# extractcountrieswithGDPdata
dd <-d[complete.cases(d$rgdppc_2000),]
# rescalevariables
dd$log_gdp_std <-dd$log_gdp/mean(dd$log_gdp)
dd$rugged_std <-dd$rugged/max(dd$rugged)
head(dd)
View(dd)
m8.1 <- quap(
alist(
log_gdp_std ~dnorm(mu,sigma),
mu <-a+b*(rugged_std-0.215),
a ~dnorm(1,1),
b ~dnorm(0,1),
sigma ~dexp(1)
) ,data=dd)
set.seed(7)
prior <-extract.prior(m8.1)
# setuptheplotdimensions
plot( NULL,xlim=c(0,1),ylim=c(0.5,1.5),
xlab="ruggedness" ,ylab="logGDP")
abline( h=min(dd$log_gdp_std),lty=2)
abline( h=max(dd$log_gdp_std),lty=2)
# draw50linesfromtheprior
rugged_seq <-seq(from=-0.1,to=1.1,length.out=30)
rugged_seq
mu <-link(m8.1,post=prior,data=data.frame(rugged_std=rugged_seq))
for (iin1:50)lines(rugged_seq,mu[i,],col=col.alpha("black",0.3))
for (i in 1:50)lines(rugged_seq,mu[i,],col=col.alpha("black",0.3))
??lines
help(lines)
# setuptheplotdimensions
plot( NULL,xlim=c(0,1),ylim=c(0.5,1.5),
xlab="ruggedness" ,ylab="logGDP")
abline( h=min(dd$log_gdp_std),lty=2)
abline( h=max(dd$log_gdp_std),lty=2)
# draw50linesfromtheprior
rugged_seq <-seq(from=-0.1,to=1.1,length.out=30)
mu <-link(m8.1,post=prior,data=data.frame(rugged_std=rugged_seq))
lines(rugged_seq,mu[1,],col=col.alpha("black",0.3))
lines(rugged_seq,mu[2,],col=col.alpha("black",0.3))
lines(rugged_seq,mu[5,],col=col.alpha("black",0.3))
rugged_seq
lines(rugged_seq,1,col=col.alpha("black",0.3))
help(link)
length(prior[[1]])
help(PSIS)
library(RSQLite)
library(data.table)
library(tidyr)
library(dplyr)
dtbinom <- function(fraction, trials, refFraction) {
dt <- data.table(fraction , trials, refFraction)
dt[, P := binom.test(x=fraction, n=trials, p = refFraction)$p.value, seq_len(nrow(dt))]$P
}
appendToDB = F
minReads = 1000
minMutReads = 200
filterReads = F
filterMutReads = F
minCountEvents = 2
removeSNVs = T
removeHDR_1MM = T
transformTDs = F
maxOutcomes = 20
writeOutcomes = TRUE
writeTornado = F
useGeneSubset = F
useRandomSubset = F
randomSubsetSize = 500
maxDistanceToCutSite = 2
if(useGeneSubset == TRUE){
con = dbConnect(RSQLite::SQLite(), dbname = "data/processed/MBCrisprMBAgain_1.2Subset_cseale.db")
} else {
con = dbConnect(RSQLite::SQLite(), dbname = "data/processed/MBCrisprMBAgain_1.2_cseale.db")
}
if(useGeneSubset == TRUE){
con = dbConnect(RSQLite::SQLite(), dbname = "data/processed/MBCrisprMBAgain_1.2Subset_cseale.db")
} else {
con = dbConnect(RSQLite::SQLite(), dbname = "data/processed/MBCrisprMBAgain_1.2_cseale.db")
}
getwd()
setwd("/Users/colm/repos/MUSICian/")
con = dbConnect(RSQLite::SQLite(), dbname = "data/processed/MBCrisprMBAgain_1.2_cseale.db")
# list of files
listFile = c("MB01", "MB02", "MB03", "MB04", "MB05","MB06","MB07","MB08")
# select DDR subset
GeneSubset = fread("src/data/GeneSubset.txt", header=T, sep = "\t", stringsAsFactors = F)
##actually some barcodes were not correct, they are correct in this file
correctBarcodeFile = "src/data/yusa_corrected.txt"
correctedBarcode = read.csv(correctBarcodeFile,sep = "\t", stringsAsFactors = F)
correctedBarcode = correctedBarcode %>% select(ID_2, ID, correctBarcode, correctGene) %>% rename(Barcode = ID)
##load the non-targetting controls
nontargettingFile = "src/data/nontarget.txt"
nontargetting = read.csv(nontargettingFile,sep = "\t", stringsAsFactors = F)
nontargetting = nontargetting %>% rename(ID_2 = id, Gene_NonT = Gene, Barcode_NonT = Barcode)
##overwrite the barcodes and genes that are used as non-targetting controls
correctedBarcode = merge(correctedBarcode, nontargetting, all.x = T, by="ID_2")
correctedBarcode = correctedBarcode %>% mutate(correctBarcode = ifelse(is.na(Barcode_NonT),correctBarcode, Barcode_NonT))
correctedBarcode = correctedBarcode %>% mutate(correctGene = ifelse(is.na(Gene_NonT),correctGene, Gene_NonT))
correctedBarcode = correctedBarcode %>% select(-Gene_NonT, -Barcode_NonT, -ID_2)
correctedBarcode = rbind(correctedBarcode,c("Empty-1","Empty-1","Empty"))
correctedBarcode = rbind(correctedBarcode,c("control","Empty-1","Empty"))
interm_non_targetting_gene_names_file = "data/interim/non-targeting_names.txt"
write.table(correctedBarcode %>% filter(correctGene == "Non-targeting"),file = interm_non_targetting_gene_names_file, row.names = F)
controlsFixed = fread("data/raw/MBcontrols_fixed_reducedCols.txt", sep = "\t", header=T, stringsAsFactors = FALSE)
randomGenes = NULL
# raw data directory
raw_data_file_dir = "data/raw/"
# process subset for debugging
row_limit = Inf
for (f in listFile) {
print(f)
if(useGeneSubset == FALSE){
file = paste0(raw_data_file_dir,f,"_reducedCols.txt")
dt = fread(file, sep = "\t", header=T, stringsAsFactors = FALSE, nrows=row_limit)
} else {
file = paste0(raw_data_file_dir,f,"_subset_reducedCols.txt")
dt = fread(file, sep = "\t", header=T, stringsAsFactors = FALSE, nrows=row_limit)
}
dt = rbind(dt, controlsFixed %>% filter(Alias == dt$Alias[1]))
rows = nrow(dt)
dt = merge(dt, correctedBarcode, by="Barcode")
dt$Barcode = dt$correctBarcode
dt$Gene = dt$correctGene
dt = dt %>% select(-correctBarcode, -correctGene)
## Subset for genelist
if(useGeneSubset == TRUE){
if(useRandomSubset == TRUE){
if(is.null(randomGenes)){
randomGenes = dt %>% select(Gene) %>% distinct() %>% sample_n(size = randomSubsetSize)
}
genes = c(randomGenes$Gene,GeneSubset$Gene)
dt = dt %>% filter(Gene %in% genes)
} else{
dt = dt %>% filter(Gene %in% GeneSubset$Gene)
}
}
#remove non-overlapping events based on distance to relative cut site
dt = dt %>% filter(delRelativeStartRight <= maxDistanceToCutSite & delRelativeEnd >= -maxDistanceToCutSite+1)
if(removeSNVs){
dt = dt %>% filter(Type != "SNV")
}
if(removeHDR_1MM){
dt = dt %>% filter(Type != "HDR1MM")
}
if(transformTDs == T){
##remove TDs and put them as DELINS here
dt = dt %>% mutate(Type = ifelse(Type == "TANDEMDUPLICATION" | Type == "TANDEMDUPLICATION_COMPOUND", "DELINS", Type))
}
### remove sgrnas with too little events
sgRNACount = dt %>% group_by(Barcode) %>% count(wt=countEvents)
sgRNAMutCount = dt %>% filter(Type != "WT") %>% group_by(Barcode) %>% count(wt=countEvents)
sgRNAsKeep = sgRNACount %>% filter(n>=minReads)
sgRNAsKeep2 = sgRNAMutCount %>% filter(n>=minMutReads)
if(filterReads == T & filterMutReads == F) {
dt = dt %>% filter(Barcode %in% sgRNAsKeep$Barcode)
} else if(filterReads == F & filterMutReads == T) {
dt = dt %>% filter(Barcode %in% sgRNAsKeep2$Barcode)
} else if(filterReads == T & filterMutReads == T){
dt = dt %>% filter(Barcode %in% sgRNAsKeep$Barcode & Barcode %in% sgRNAsKeep2$Barcode)
}
##add a countTable to the DB
countTable = dt %>% group_by(Alias, Barcode, Gene) %>% summarise(allEvents = sum(countEvents))
countTableNonWT = dt %>% filter(Type != "WT") %>% group_by(Barcode) %>% summarise(mutEvents = sum(countEvents))
countTable = merge(countTable, countTableNonWT, by = "Barcode")
dbWriteTable(conn = con, name = "countTable", countTable, append = appendToDB, overwrite = !appendToDB)
dt$SubType = dt$Type
dt$outcome <- paste(dt$Type,dt$delRelativeStart,dt$delRelativeEnd,dt$insert,paste0(dt$homologyLength,"bp"),sep = "|")
currentRows = nrow(dt)
print(paste("Initial rows", rows," reduced to ",currentRows, "fraction:",currentRows/rows))
if (writeOutcomes) {
print("Preparing outcomes table")
dtOutcomes = dt %>% group_by(Alias, Barcode) %>% mutate(fraction_per_barcode = fraction/sum(fraction))
outcomes = dtOutcomes %>% select(Alias, Gene, Barcode, outcome, fraction_per_barcode, Type, countEvents, delRelativeStart, delRelativeEnd, delSize, insSize, homologyLength, insertion)
test = merge(outcomes, countTable %>% select(-Alias, -Gene), by = "Barcode")
# We will ignore these p-value tests for now, may come back to these later
# test = merge(outcomes, countTableGene, by = "Gene")
# test = test %>% mutate(trials = ifelse(outcomeTop == "WT|0|0||-1bp", countEvents, mutEvents))
# test = test %>% mutate(counts = floor(fraction*trials))
# test = test %>% group_by(outcomeTop) %>% mutate(mean = mean(fraction))
# test$Pvalue = -log10(dtbinom(test$counts, test$trials, test$mean))
# test = test %>% mutate(Pvalue = ifelse(Pvalue == Inf, 300, Pvalue))
print(paste("Writing outcomes gene",nrow(outcomes)))
dbWriteTable(conn = con, name = "outcomes", test, append = appendToDB, overwrite = !appendToDB)
print("Writing done genes")
}
appendToDB = T
}
dbExecute(con, 'create index outcomes_full_idx on outcomes (Alias, Gene, Barcode, outcome, fraction_per_barcode, countEvents)')
dbDisconnect(conn = con)
## clean up
dt = NULL
dtBarcode = NULL
dtGene = NULL
